<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Ramallah Waste Containers</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" />
  <style>
    body { margin: 0; height: 100%; width: 100%; }
    #map { position: absolute; width: 100%; top: 0; bottom: 0; }
    .floating-info { position: absolute; background-color: white; padding: 10px; border: 1px solid #ccc; border-radius: 5px; z-index: 1000; display: none; }
    .legend { position: absolute; top: 10px; right: 10px; background-color: white; padding: 10px; border: 1px solid #ccc; border-radius: 5px; z-index: 1000; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="floating-info" id="infoBox"></div> <!-- Floating information box -->
  <div class="legend" id="legend"></div> <!-- Legend -->
  <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script>
    const mapOptions = {
      zoomSnap: 0.5,
      center: [31.9045, 35.2045],
      zoom: 19,
    };
    const map = L.map("map", mapOptions);

    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; OpenStreetMap & CARTO',
      subdomains: 'abcd',
      maxZoom: 20
    }).addTo(map);

    let zonesLayer, wasteContainersLayer;
    const events = [{ name: "Festival", location: [31.905, 35.203], impactRadius: 0.01, wasteIncrease: 0.2 }];
    const weatherImpact = { "hot": 0.3, "rainy": 0.2 };

    // Function to generate ascending colors based on zone name (using a color scale)
    function getColorForZone(index) {
      const colorScale = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#8a2be2']; // Example gradient
      return colorScale[index % colorScale.length];
    }

    // Function to generate the fill color dynamically based on feature properties (ascending order)
    function styleZones(feature) {
      const zones = ["Zone1", "Zone2", "Zone3", "Zone4", "Zone5"];
      const index = zones.indexOf(feature.properties.NAME_ENGLI);
      return {
        fillColor: getColorForZone(index),
        fillOpacity: 0.3,
        color: getColorForZone(index),
        weight: 1.0,
        opacity: 0.7
      };
    }

    function getFillStatus(size) {
      return Math.random() * size;
    }

    function checkNearbyEvent(latlng) {
      for (let event of events) {
        let distance = map.distance(latlng, event.location) / 1000;
        if (distance < event.impactRadius) {
          return event.wasteIncrease;
        }
      }
      return 0;
    }

    $.getJSON("RamallahZones.json", function(RZ) {
      zonesLayer = L.geoJson(RZ, {
        style: styleZones,
        onEachFeature: function(feature, layer) {
          layer.on('click', function(e) {
            const infoBox = document.getElementById('infoBox');
            infoBox.style.display = 'block';
            infoBox.style.left = (e.containerPoint.x + 15) + 'px';
            infoBox.style.top = (e.containerPoint.y + 15) + 'px';
            infoBox.innerHTML = `<strong>Zone:</strong> ${feature.properties.NAME_ENGLI} <br><strong>MAIL_CODE:</strong> ${feature.properties.MAIL_CODE}`;
          });
        }
      }).addTo(map);
      suggestNewContainerLocations(zonesLayer);
      suggestRecyclingPoints(zonesLayer);
    });

    $.getJSON("wasteContainer.json", function(WC) {
      wasteContainersLayer = L.geoJson(WC, {
        pointToLayer: function(feature, latlng) {
          const eventImpact = checkNearbyEvent(latlng);
          const isHotDay = true;
          const impact = isHotDay ? weatherImpact.hot : 0;
          const fillStatus = getFillStatus(feature.properties.SIZE_OF_TH) * (1 + eventImpact) * (1 + impact);
          const color = fillStatus > 0.8 * feature.properties.SIZE_OF_TH ? 'red' : 'orange';
          return L.circleMarker(latlng, { radius: 5, fillColor: color, color: color, weight: 1, opacity: 1, fillOpacity: 0.8 });
        },
        onEachFeature: function(feature, layer) {
          const prediction = predictWastePattern(layer);
          const wasteType = feature.properties.TYPE_OF_WA;
          layer.bindPopup(`<strong>Material:</strong> ${wasteType} <br><strong>Size:</strong> ${feature.properties.SIZE_OF_TH} <br><strong>Prediction:</strong> ${prediction}`);
          layer.setStyle({ fillColor: setWasteTypeColor(wasteType) });
        }
      }).addTo(map);
      calculateOptimalRoute(wasteContainersLayer.getLayers());
    });

    function setWasteTypeColor(type) {
      switch (type) {
        case "Plastic": return "yellow";
        case "Organic": return "green";
        case "Metal": return "grey";
        default: return "orange";
      }
    }

    function predictWastePattern(layer) {
      const usagePattern = Math.random();
      return usagePattern > 0.6 ? "High accumulation expected" : "Normal levels expected";
    }

    function suggestNewContainerLocations(zonesLayer) {
      zonesLayer.eachLayer(function(layer) {
        const centroid = layer.getBounds().getCenter();
        L.circleMarker(centroid, { radius: 6, fillColor: 'blue', color: 'blue', weight: 2, fillOpacity: 0.6 }).bindPopup("Suggested Container Location").addTo(map);
      });
    }

    function suggestRecyclingPoints(zonesLayer) {
      zonesLayer.eachLayer(function(layer) {
        if (layer.feature.properties.commonWasteType === "Plastic") {
          L.marker(layer.getBounds().getCenter(), { icon: L.divIcon({ className: 'recycling-icon', html: 'â™»' }) }).bindPopup("Suggested Recycling Point for Plastic").addTo(map);
        }
      });
    }

    function calculateOptimalRoute(containers) {
      for (let i = 0; i < containers.length - 1; i++) {
        L.polyline(
          [containers[i].getLatLng(), containers[i + 1].getLatLng()],
          {
            color: 'blue',     // Change the color to blue
            weight: 2,
            opacity: 0.5       // Add transparency for reduced overlap
          }
        ).addTo(map).bindPopup("Suggested collection path");
      }
    }

    // Create the legend dynamically
    function createLegend() {
      const legend = document.getElementById('legend');
      legend.innerHTML = `<h4>Legend</h4>
        <p><strong>Zones</strong></p>
        <div><span style="background-color: red;"></span> Zone1</div>
        <div><span style="background-color: blue;"></span> Zone2</div>
        <div><span style="background-color: green;"></span> Zone3</div>
        <div><span style="background-color: purple;"></span> Zone4</div>`;
    }

    createLegend(); // Call legend creation function
  </script>
</body>
</html>
